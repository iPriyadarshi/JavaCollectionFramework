Index: src/structures/data/HashCodeAndEqualsMethod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/structures/data/HashCodeAndEqualsMethod.java b/src/structures/data/HashCodeAndEqualsMethod.java
new file mode 100644
--- /dev/null	(date 1757265295929)
+++ b/src/structures/data/HashCodeAndEqualsMethod.java	(date 1757265295929)
@@ -0,0 +1,84 @@
+package structures.data;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public class HashCodeAndEqualsMethod {
+    public static void main(String[] args) {
+        // Create a HashMap with Person as key and String as value
+        HashMap<Person, String> map = new HashMap<>();
+
+        // Create three Person objects
+        Person p1 = new Person("Alice", 1); // Unique object
+        Person p2 = new Person("Bob", 2);   // Unique object
+        Person p3 = new Person("Alice", 1); // Same data as p1, but different instance
+
+        // Insert entries into the map
+        map.put(p1, "Engineer");  // Adds new entry
+        map.put(p2, "Designer");  // Adds new entry
+        map.put(p3, "Manager");   // p3 is equal to p1 → replaces value at p1's key
+
+        // Print map size — should be 2, because p1 and p3 are considered equal
+        System.out.println("HashMap Size: " + map.size()); // Output: 2
+
+        // Retrieve values using p1 and p3 — both point to same key
+        System.out.println("Value for p1: " + map.get(p1)); // Output: Manager
+        System.out.println("Value for p3: " + map.get(p3)); // Output: Manager
+
+        // Demonstrate same behavior with String keys
+        Map<String, Integer> map1 = new HashMap<>();
+        map1.put("Shubham", 90); // Adds new entry
+        map1.put("Neha", 92);    // Adds new entry
+        map1.put("Shubham", 99); // Replaces value for "Shubham"
+
+        System.out.println("Value for 'Shubham': " + map1.get("Shubham")); // Output: 99
+        System.out.println("Value for 'Neha': " + map1.get("Neha"));       // Output: 92
+    }
+}
+
+// Custom class used as key in HashMap
+class Person {
+    private String name;
+    private int id;
+
+    public Person(String name, int id) {
+        this.name = name;
+        this.id = id;
+    }
+
+    // Getters
+    public String getName() {
+        return name;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * hashCode() is used by HashMap to determine the bucket index.
+     * Two objects with same hashCode might still be different unless equals() returns true.
+     */
+    @Override
+    public int hashCode() {
+        return Objects.hash(name, id); // Combines name and id to generate hash
+    }
+
+    /**
+     * equals() is used to check logical equality.
+     * HashMap uses equals() to resolve collisions and determine if keys are the same.
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true; // Same reference
+        if (obj == null || getClass() != obj.getClass()) return false; // Null or different class
+        Person other = (Person) obj;
+        return id == other.id && Objects.equals(name, other.name); // Logical equality
+    }
+
+    @Override
+    public String toString() {
+        return "id: " + id + ", name: " + name;
+    }
+}
\ No newline at end of file
